const { Server } = require("socket.io");
const Chat = require("./models/Chat");
const Message = require("./models/Message");
const { getRandomQuote } = require("./utils/zenQuotesClient");

let io;
let liveEnabled = false;
let liveTimer = null;

function setupSocket(server, allowedOrigins) {
  io = new Server(server, {
    cors: {
      origin: allowedOrigins,
      credentials: true,
      methods: ["GET", "POST", "PATCH"],
    },
    transports: ["websocket", "polling"],
  });

  io.on("connection", (socket) => {
    console.log("Socket connected:", socket.id);

    socket.on("joinChat", (chatId) => {
      socket.join(chatId);
      console.log(`Socket ${socket.id} joined chat ${chatId}`);
    });

    // Toggle live режим ---
    socket.on("toggleLive", ({ enabled }) => {
      const prev = liveEnabled;
      liveEnabled = !!enabled;

      if (liveEnabled && !prev) startLive();
      if (!liveEnabled && prev) stopLive();

      console.log(`[LIVE] mode: ${liveEnabled ? "ON" : "OFF"}`);
      io.emit("notification", { type: "live_state", enabled: liveEnabled });
    });

    socket.on("disconnect", (reason) => {
      console.log(`Socket disconnected: ${socket.id}, reason: ${reason}`);
    });
  });
}

// Автоматичне надсилання повідомлень у випадковий чат ---
function startLive() {
  if (liveTimer) return;
  liveTimer = setInterval(async () => {
    try {
      const count = await Chat.countDocuments();
      if (!count) return;

      const randomIndex = Math.floor(Math.random() * count);
      const chat = await Chat.findOne().skip(randomIndex);
      if (!chat) return;

      const quote = await getRandomQuote();

      const msg = await Message.create({
        chatId: chat._id,
        text: quote,
        sender: "bot",
        autoGenerated: true,
        createdAt: new Date(),
      });

      broadcastNewMessage(msg);
      console.log(`[LIVE] Sent auto message to chat ${chat.firstName}`);
    } catch (err) {
      console.error("[LIVE] Error:", err.message);
    }
  }, 5000); // кожні 5 секунд
}

function stopLive() {
  if (liveTimer) {
    clearInterval(liveTimer);
    liveTimer = null;
  }
}

// Трансляція нового повідомлення ---
function broadcastNewMessage(msg) {
  if (!io) return;
  const payload = {
    ...(msg.toObject?.() || msg),
    chatId: String(msg.chatId),
    _id: String(msg._id),
  };
  io.to(payload.chatId).emit("newMessage", payload);
  io.emit("notification", {
    type: "new_message",
    chatId: payload.chatId,
    text: payload.text,
  });
  console.log("[SOCKET] broadcast newMessage ->", payload.chatId);
}

// Трансляція оновленого повідомлення
function broadcastMessageUpdated(msg) {
  if (!io) return;
  const payload = {
    ...(msg.toObject?.() || msg),
    chatId: String(msg.chatId),
    _id: String(msg._id),
  };
  io.to(payload.chatId).emit("messageUpdated", payload);
  io.emit("notification", {
    type: "message_updated",
    chatId: payload.chatId,
    text: payload.text,
  });
  console.log("[SOCKET] broadcast messageUpdated ->", payload.chatId);
}

module.exports = { setupSocket, broadcastNewMessage, broadcastMessageUpdated };
