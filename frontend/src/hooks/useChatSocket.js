import { useEffect } from "react";
import socket from "@/services/socket";
import { normalizeId } from "@/utils/ids";

//Підписуємось на сокетні події, керує спливаючими повідомленнями (toasts)/лічильниками непрочитаних/попередніми переглядами (previews)

export function useChatSocket({
  setMessages,
  setChats,
  setLiveEnabled,
  activeChatIdRef,
  chatsRef,
  toastRef,
  liveRef,
}) {
  useEffect(() => {
    try {
      if (!socket.connected) socket.connect();

      const onNewMessage = (msg) => {
        const currentId = normalizeId(activeChatIdRef.current);
        const msgChatId = normalizeId(msg.chatId);
        const chats = chatsRef.current;
        const toast = toastRef.current;

        if (!liveRef.current && msg.autoGenerated) return;

        // Повідомлення прийшло в чат, який зараз відкрито
        if (currentId === msgChatId) {
          setMessages((prev) => [...prev, msg]);

          if (msg.sender !== "user") {
            toast.push("New message in this chat");
          }

          // Оновлюємо попередній перегляд лише для активного чату
          setChats((prev) =>
            prev.map((c) =>
              normalizeId(c._id) === msgChatId
                ? { ...c, lastMessage: { text: msg.text } }
                : c
            )
          );
          return;
        }

        // Повідомлення прийшло в інший чат
        const chat = chats.find((c) => normalizeId(c._id) === msgChatId);
        const name = chat
          ? `${chat.firstName || ""} ${chat.lastName || ""}`.trim()
          : "another chat";

        if (msg.sender !== "user") {
          toast.push(`New message in ${name}`);
        }

        setChats((prev) =>
          prev.map((c) =>
            normalizeId(c._id) === msgChatId
              ? {
                  ...c,
                  lastMessage: { text: msg.text },
                  unreadCount: (c.unreadCount || 0) + 1,
                }
              : c
          )
        );
      };

      const onMessageUpdated = (msg) => {
        const currentId = normalizeId(activeChatIdRef.current);
        if (normalizeId(msg.chatId) !== currentId) return;
        setMessages((prev) =>
          prev.map((m) => (m._id === msg._id ? { ...m, text: msg.text } : m))
        );
      };

      const onNotification = (n) => {
        if (n.type === "live_state") setLiveEnabled(n.enabled);
      };

      socket.on("newMessage", onNewMessage);
      socket.on("messageUpdated", onMessageUpdated);
      socket.on("notification", onNotification);

      return () => {
        socket.off("newMessage", onNewMessage);
        socket.off("messageUpdated", onMessageUpdated);
        socket.off("notification", onNotification);
      };
    } catch (err) {
      console.error("Socket setup error:", err);
    }
  }, [
    setMessages,
    setChats,
    setLiveEnabled,
    activeChatIdRef,
    chatsRef,
    toastRef,
    liveRef,
  ]);
}
