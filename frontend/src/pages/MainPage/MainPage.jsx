import React, { useState, useEffect, useRef } from "react";
import s from "./MainPage.module.css";
import ChatList from "@/components/chat/ChatList/ChatList.jsx";
import ChatWindow from "@/components/chat/ChatWindow/ChatWindow.jsx";
import NewChatModal from "@/components/chat/NewChatModal/NewChatModal.jsx";
import EditChatModal from "@/components/chat/EditChatModal/EditChatModal.jsx";
import ConfirmDialog from "@/components/chat/ConfirmDialog/ConfirmDialog.jsx";
import {
  getChats,
  createChat,
  updateChat,
  deleteChat,
  getMessages,
  sendMessage,
  updateMessage,
} from "@/services";
import socket from "@/services/socket";
import { useToast } from "@/contexts/Toast/ToastContext";

export default function MainPage() {
  const toast = useToast();

  const [chats, setChats] = useState([]);
  const [activeChat, setActiveChat] = useState(null);
  const [messages, setMessages] = useState([]);

  const [isNewChatModalOpen, setIsNewChatModalOpen] = useState(false);
  const [editChat, setEditChat] = useState(null);
  const [confirmDelete, setConfirmDelete] = useState(null);

  const [searchTerm, setSearchTerm] = useState("");
  const [liveEnabled, setLiveEnabled] = useState(false);

  // refs
  const activeChatIdRef = useRef(null);
  const chatsRef = useRef([]);
  const toastRef = useRef(toast);
  const liveRef = useRef(liveEnabled);
  const joinedChatsRef = useRef(new Set()); // ✅ трекінг приєднаних кімнат

  const normalizeId = (id) =>
    typeof id === "object" && id?.$oid ? id.$oid : String(id || "");

  useEffect(() => {
    chatsRef.current = chats;
    toastRef.current = toast;
  }, [chats, toast]);

  useEffect(() => {
    liveRef.current = liveEnabled;
  }, [liveEnabled]);

  // --- сокет ---
  useEffect(() => {
    if (!socket.connected) socket.connect();

    const onNewMessage = (msg) => {
      const currentId = activeChatIdRef.current;
      const msgChatId = normalizeId(msg.chatId);
      const chats = chatsRef.current;
      const toast = toastRef.current;

      if (!liveRef.current && msg.autoGenerated) return;

      // якщо активний чат
      if (normalizeId(currentId) === msgChatId) {
        setMessages((prev) => [...prev, msg]);

        if (msg.sender !== "user") {
          toast.push("Нове повідомлення в цьому чаті");
        }

        setChats((prev) =>
          prev.map((c) =>
            normalizeId(c._id) === msgChatId
              ? { ...c, lastMessage: { text: msg.text } }
              : c
          )
        );
        return;
      }

      // якщо інший чат
      const chat = chats.find((c) => normalizeId(c._id) === msgChatId);
      const name = chat
        ? `${chat.firstName || ""} ${chat.lastName || ""}`.trim()
        : "іншому чаті";

      if (msg.sender !== "user") {
        toast.push(`Нове повідомлення у ${name}`);
      }

      setChats((prev) =>
        prev.map((c) =>
          normalizeId(c._id) === msgChatId
            ? {
                ...c,
                lastMessage: { text: msg.text },
                unreadCount: (c.unreadCount || 0) + 1,
              }
            : c
        )
      );
    };

    const onMessageUpdated = (msg) => {
      const currentId = activeChatIdRef.current;
      if (normalizeId(msg.chatId) !== normalizeId(currentId)) return;
      setMessages((prev) =>
        prev.map((m) => (m._id === msg._id ? { ...m, text: msg.text } : m))
      );
    };

    const onNotification = (n) => {
      if (n.type === "live_state") setLiveEnabled(n.enabled);
    };

    socket.on("newMessage", onNewMessage);
    socket.on("messageUpdated", onMessageUpdated);
    socket.on("notification", onNotification);

    return () => {
      socket.off("newMessage", onNewMessage);
      socket.off("messageUpdated", onMessageUpdated);
      socket.off("notification", onNotification);
    };
  }, []);

  // --- чати ---
  useEffect(() => {
    const t = setTimeout(() => {
      getChats(searchTerm)
        .then((res) =>
          setChats((prev) =>
            res.data.map((newChat) => {
              const old = prev.find((p) => p._id === newChat._id);
              return old
                ? {
                    ...newChat,
                    unreadCount: old.unreadCount || 0,
                    lastMessage: old.lastMessage,
                  }
                : newChat;
            })
          )
        )
        .catch(() => toast.push("Не вдалося завантажити чати"));
    }, 300);
    return () => clearTimeout(t);
  }, [searchTerm, toast]);

  // 🔗 приєднуємося до всіх чатів лише один раз
  useEffect(() => {
    if (!socket.connected || chats.length === 0) return;

    chats.forEach((chat) => {
      const id = String(chat._id);
      if (!joinedChatsRef.current.has(id)) {
        socket.emit("joinChat", id);
        joinedChatsRef.current.add(id);
      }
    });
  }, [chats]);

  // --- повідомлення ---
  useEffect(() => {
    if (!activeChat) return;
    activeChatIdRef.current = activeChat._id;
    getMessages(activeChat._id)
      .then((res) => setMessages(res.data))
      .catch(() => toast.push("Не вдалося завантажити повідомлення"));
  }, [activeChat, toast]);

  useEffect(() => {
    if (activeChat) socket.emit("joinChat", activeChat._id);
  }, [activeChat]);

  // --- CRUD ---
  const handleNewChat = async (chat) => {
    try {
      const res = await createChat(chat);
      setChats((prev) => [...prev, res.data]);
      toast.push("Чат створено");
    } catch {
      toast.push("Не вдалося створити чат");
    }
  };

  const handleEditChat = async (chatId, updatedData) => {
    try {
      const res = await updateChat(chatId, updatedData);
      setChats((prev) =>
        prev.map((chat) => (chat._id === chatId ? res.data : chat))
      );
      toast.push("Чат оновлено");
    } catch {
      toast.push("Не вдалося оновити чат");
    }
  };

  const handleDeleteChat = async (chat) => {
    try {
      await deleteChat(chat._id);
      setChats((prev) => prev.filter((c) => c._id !== chat._id));
      if (activeChat?._id === chat._id) setActiveChat(null);
      toast.push("Чат видалено");
    } catch {
      toast.push("Не вдалося видалити чат");
    }
  };

  const handleSendMessage = async (text) => {
    if (!activeChat) return;
    try {
      await sendMessage(activeChat._id, { text, sender: "user" });
    } catch {
      toast.push("Не вдалося надіслати повідомлення");
    }
  };

  const handleEditMessage = async (messageId, newText) => {
    try {
      await updateMessage(messageId, { text: newText });
    } catch {
      toast.push("Не вдалося оновити повідомлення");
    }
  };

  // --- вибір чату ---
  const handleSelectChat = (chat) => {
    setActiveChat(chat);
    setChats((prev) =>
      prev.map((c) =>
        normalizeId(c._id) === normalizeId(chat._id)
          ? { ...c, unreadCount: 0, lastMessage: null }
          : c
      )
    );
  };

  // --- тумблер Live ---
  const handleToggleLive = (e) => {
    const enabled = e.target.checked;
    setLiveEnabled(enabled);
    socket.emit("toggleLive", { enabled });
    setTimeout(() => {
      toast.push(`Live mode ${enabled ? "is on" : "is off"}`);
    }, 100);
  };

  return (
    <div className={s.wrapper}>
      <aside className={s.sidebar}>
        <ChatList
          chats={chats}
          activeId={activeChat?._id}
          onSelect={handleSelectChat}
          onNew={() => setIsNewChatModalOpen(true)}
          onEdit={(chat) => setEditChat(chat)}
          onDelete={(chat) => setConfirmDelete(chat)}
          onSearch={setSearchTerm}
          liveEnabled={liveEnabled}
          onToggleLive={handleToggleLive}
        />
      </aside>

      <section className={s.chatArea}>
        <ChatWindow
          chat={activeChat}
          messages={messages}
          onSend={handleSendMessage}
          onEditMessage={handleEditMessage}
        />
      </section>

      {isNewChatModalOpen && (
        <NewChatModal
          onClose={() => setIsNewChatModalOpen(false)}
          onCreate={handleNewChat}
        />
      )}

      {editChat && (
        <EditChatModal
          chat={editChat}
          onClose={() => setEditChat(null)}
          onSave={(data) => {
            handleEditChat(editChat._id, data);
            setEditChat(null);
          }}
        />
      )}

      {confirmDelete && (
        <ConfirmDialog
          message={`Видалити чат з ${confirmDelete.firstName}?`}
          onCancel={() => setConfirmDelete(null)}
          onConfirm={() => {
            handleDeleteChat(confirmDelete);
            setConfirmDelete(null);
          }}
        />
      )}
    </div>
  );
}
